<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[NSGuy]]></title>
  <link href="http://nsguy.com/atom.xml" rel="self"/>
  <link href="http://nsguy.com/"/>
  <updated>2014-02-09T15:00:08+08:00</updated>
  <id>http://nsguy.com/</id>
  <author>
    <name><![CDATA[John]]></name>
    <email><![CDATA[songyingxinok@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CoreData并发处理]]></title>
    <link href="http://nsguy.com/blog/2014/02/09/learning-core-data/"/>
    <updated>2014-02-09T13:44:08+08:00</updated>
    <id>http://nsguy.com/blog/2014/02/09/learning-core-data</id>
    <content type="html"><![CDATA[<p>CoreData 怎么处理多线程的问题呢，自从iOS 5.0 以后， 苹果给CoreData 添加了一些新的API，但是由于从前对于UI层面关注比较多，底层的东西关注过少，导致到现在才开始重新看CoreData这块的内容。</p>

<p>iOS 5.0 苹果为CoreData的并发处理添加了两个内容。</p>

<p><strong>首先介绍第一个：</strong></p>

<pre><code>- (id)initWithConcurrencyType:(NSManagedObjectContextConcurrencyType)ct
</code></pre>

<p>NSManagedObjectContextConcurrencyType 一共有三种:</p>

<ul>
  <li>NSConfinementConcurrencyType</li>
  <li>NSPrivateQueueConcurrencyType</li>
  <li>NSMainQueueConcurrencyType</li>
</ul>

<p><code>NSConfinementConcurrencyType</code>：每一条线程只能有唯一的一个ManagedObjectContext的模式。与此相对应，苹果的官方文档给出了两种解决并发问题的方案：</p>

<ol>
  <li>
    <p>Create a separate managed object context for each thread and share a single persistent store coordinator. This is the typically-recommended approach.</p>
  </li>
  <li>
    <p>Create a separate managed object context and persistent store coordinator for each thread. This approach provides for greater concurrency at the expense of greater complexity (particularly if you need to communicate changes between different contexts) and increased memory usage.</p>
  </li>
</ol>

<p><code>NSPrivateQueueConcurrencyType</code> 与 <code>NSMainQueueConcurrencyType</code>:分别对应绑定一个后台线程与主线程。可以使用performBlock:开执行原来需要使用dispatch_async封装的代码.</p>

<p><code>NSConfinementConcurrencyType</code>不能执行<code>performBlock</code>:.</p>

<p><strong>第二个内容： Nested ManagedObjectContext</strong></p>

<pre><code>Nested contexts allow you to set up a managed object context so that it accesses data from a parent context instead of from a persistent store. If you request an object from a managed object context that has a parent context, Core Data will first look in the parent. If the parent context has that object in memory, you’ll get a new managed object just like that one. So if there are changes in the parent, you’ll get the changed version of the object. If the object doesn’t exist in that context, it will keep going up through parent contexts until it finally fetches the data from the persistent store.
</code></pre>

<p>也就是说，当子Context中做保存操作时，因为子context没有persistentStoreCoordinator ，这个变化会首先推送给他的父context，这个操作将一直传递，直到找到没有父Context的RootContext为止，当rootContext收到这个消息的时候，rootContext自动合并了这次操作，并且做了最终的保存。所以子context查找时，同样也会首先从父context那里查找而不是直接与persistentStoreCoordinator交流。当使用这种结构时，不需要特别去监听NSManagedObjectContextObjectsDidChangeNotification 来合并异步操作到主线程，这也是这种结构的方便之处。</p>

<p>对于这种结构，我找到了来自Florian Kugler的几种并发策略:</p>

<p><strong>策略一 :</strong></p>

<p>同样使用了Nested ManagedObjectContext,但是使用了PrivateQueue作为主Context。对于Worker Context作操作将会经由MainQueue Context 最终由MasterContext合并。这个方案的好处在于Worker Context都是临时工，不需要考虑他们的生命周期。另外的一个好处是，由于他们不能自动获取到来自父亲的更新，所以这个任务可以再未完成之前随时取消。</p>

<p><strong>关于死锁</strong></p>

<p>无论何时只要对PersistentStoreCoordinator做写的操作都会造成死锁，但是这个方案的一个好处在于，如果只是做读的操作，是从内存中的，所以不会造成死锁。但是死锁的问题还是要考虑进去的。</p>

<p><img src="http://static.squarespace.com/static/5159eb3de4b01cd3b022715d/t/517e6219e4b0f470ac92f51a/1367237146374/stack%202.png?format=500w" alt="策略一" /></p>

<p>示例：</p>

<pre><code>- (NSManagedObjectContext *)mainThreadContext{
	if (!_mainThreadContext) {
    	_mainThreadContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
    	_mainThreadContext.parentContext = [self backgroundContext];
	}
    return _mainThreadContext;
}

- (NSManagedObjectContext *)backgroundContext{
    if (!_backgroundObjectContext) {
        _backgroundObjectContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType];
        [_backgroundObjectContext setPersistentStoreCoordinator:_storeCoordinator];
        
    }
    return _backgroundObjectContext;
}

- (NSManagedObjectContext *)temporaryContext{
    NSManagedObjectContext *temporaryContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType];
    temporaryContext.parentContext = [self mainThreadContext];
    return temporaryContext;
}
</code></pre>

<p><strong>策略二 :</strong></p>

<p>传统的方式，两个线程都使用同一个持久化存取器，不使用嵌套的结构，而使用<code>NSManagedObjectContextObjectsDidChangeNotification</code>合并来自其他线程的变化。这种方法处理起来要注意几点</p>

<p>每一条线程都应该是一个独立的<code>ManagedObjectContext</code>
监听<code>NSManagedObjectContextObjectsDidChangeNotification</code> 时，应该传递context，因为系统也可能会发送通知。</p>

<pre><code> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(managedObjectContextDidChanged:) name:NSManagedObjectContextObjectsDidChangeNotification object:objectContext];
</code></pre>

<p><img src="http://static.squarespace.com/static/5159eb3de4b01cd3b022715d/t/517e6235e4b01510f836b35d/1367237173926/stack%203.png?format=750w" alt="策略二" /></p>

<p>三种策略都可以处理CoreData 并发的问题，有些人比较推崇的是第一个方案，但是同时Florian Kugler经过测试发现当读取大量的数据时，策略二花费的总时间与在主线程花费的时间最少。详细原因可以阅读下面的文章。我觉得关于到底采取哪种方案还是通过自己的实践来。</p>

<p>参考</p>

<ul>
  <li><a href="http://www.cocoanetics.com/2012/07/multi-context-coredata/">Multi Context CoreData</a></li>
  <li><a href="http://floriankugler.com/blog/2013/4/29/concurrent-core-data-stack-performance-shootout">Concurrent Core Data Stack Perforamnce Shoot Out</a></li>
  <li><a href="http://floriankugler.com/blog/2013/5/11/backstage-with-nested-managed-object-contexts">Backstahe with nested managed object contexts</a></li>
  <li><a href="http://wbyoung.tumblr.com/post/27851725562/core-data-growing-pains">Core Data Growing Pain</a></li>
  <li><a href="http://www.cocoanetics.com/2013/02/zarra-on-locking/">CoreData Locking</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[起源]]></title>
    <link href="http://nsguy.com/blog/2013/12/07/%E5%8A%9B%E9%87%8F%E7%9A%84%E8%B5%B7%E6%BA%90/"/>
    <updated>2013-12-07T14:41:40+08:00</updated>
    <id>http://nsguy.com/blog/2013/12/07/力量的起源</id>
    <content type="html"><![CDATA[<p>我喜欢游戏，喜欢8-bit，喜欢吉他，喜欢好的设计，希望这里将是我分享的一个好的起点。<br />
Octopress + Github Pages 是一个搭建私人博客的比较hack的方式，就像Octopress介绍自己说的：<code>A blogging framework for hackers</code>!</p>

<h2 id="ruby">搭建Ruby环境</h2>
<p>使用RVM（Ruby Version Manager）来负责安装与管理Ruby的环境。在做这一切之前，先安装好Homebrew能解决很多<code>command not found</code>的问题</p>

<ul lang="shell">
  <li>
    <h4 id="homebrew">安装Homebrew</h4>
    <pre><code>ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go/install)"
</code></pre>
  </li>
</ul>

<ul>
  <li>
    <h4 id="rvm">安装RVM</h4>

    <pre><code>  curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>

    <p>这里获取的是最新的ruby版本，目前我取下来的版本是2.0.0。如果需要使用1.9.3环境</p>

    <pre><code>  rvm install 1.9.3
  rvm use 1.9.3
  rvm rubygems latest
</code></pre>

    <p>搭建好RVM之后就可以正式开始搭建Octopress了。cd 到你想要保存octopress的目录下，然后在终	端输入：</p>

    <pre><code>  git clone git://github.com/imathis/octopress.git octopress
</code></pre>

    <p>下一步是安装相关的依赖：</p>

    <pre><code>  gem install bundler
  bundle install
</code></pre>

    <p>最后安装默认主题：</p>

    <pre><code>  rake install
</code></pre>

    <p>这样子octopress就算基本搭建好了，下面的步骤就是怎么上传到github上了。</p>
  </li>
</ul>

<p>小结: 在搭建环境的时候，发生了非常多的command not found的问题，直到我安装了homebrew + google所遇到的问题之后，一切迎刃而解了。</p>

<h2 id="octopress">配置Octopress</h2>
<p>首先在 Github 上创建一个由你自己的用户名组成的repo，如<code>yourusername.github.com</code>，注意这里必须是由你自己的user name 组成。然后第一次提	交会有两个分支，一个是<code>source</code>分支，一个是<code>master</code>分支。<code>source</code>管理博	客的源码，<code>master</code>分支用于管理生成的内容。Octopress的做法似乎是把<code>master</code>分	支对<code>source</code>下的<strong><em>source</em></strong>文件夹做了映射，然后每次都会deploy的时候都会把这个文	件夹提交到<code>master</code>。</p>

<p>创建好了repo之后就可以自动生成github的页面，输入：</p>

<pre><code>rake setup_github_pages
</code></pre>

<p>然后终端会让你输入你Github上的repo地址，这里注意不要根据它给的样式输入，找到自己的仓库地址，格式是：<code>git@github.com:yourusername/yourusername.github.com.git</code>，这里如果输入错误，之后就提交不到仓库了，我在这里遇到了这个问题导致后面一直提交不上去，浪费了时间。</p>

<p>然后输入</p>

<pre><code>rake generate
rake deploy
</code></pre>

<p>最后把代码提交到仓库了</p>

<pre><code>git add .
git commit -m 'Initial octopress'
git push origin source
</code></pre>

<p>到了这一步，就可以在浏览器输入<code>yourusername.github.com</code>访问你的Github Pages了。</p>

<h2 id="section">发布文章</h2>
<p>输入</p>

<pre><code>rake new_post["title"]
</code></pre>

<p>就会在source/_post 文件夹生成一份年月日生成的markdown文件，我们就是通过这个来写文章的。写好文章之后，一般的步骤是</p>

<pre><code>rake generate
git add . 
git commit -i 'change log'	
git push origin source
rake deploy 这样就把文章发布到你的私人博客上了，easy!
</code></pre>

<h2 id="section-1">那些烦人的404</h2>
<p>提交代码到Github之后，但是仍不能访问页面，这里以我遇到的问题为例：</p>

<ul>
  <li>
    <h4 id="recognized-liquid-tag">recognized Liquid tag</h4>

    <blockquote>
      <p>The page build failed with the following error:
  The tag <code>include_array</code> in <code>source/index.html</code> is not a recognized Liquid 	tag.”
  and i just simply delete the code below and everything works fine in local 	preview.</p>
    </blockquote>

    <p>如果Github给你发邮件报这个问题，那很有可能你把整个source分支都提交到了master引起的错误。</p>
  </li>
  <li>
    <h4 id="submodule">submodule</h4>
    <p>如果你遇到了关于submodule的错误，比如在安装greyshade主题的时候。那么只要删除这个文件夹就好了</p>

    <pre><code>  git rm --cached .theme/greyshade
</code></pre>
  </li>
  <li>
    <h4 id="rejected-master---master-non-fast-forward">[rejected] master -&gt; master (non-fast-forward)</h4>
    <p>当提交到master的时候遇到这个问题，可以查看<a href="http://	stackoverflow.com/questions/17609453/rake-gen-deploy-rejected-in-octopress" title="Title">stackoverflow上的解决方案</a></p>
  </li>
</ul>

<h2 id="section-2">小结</h2>
<p>花了两天的时间，才把 Github Pages 搭建好了，有意思的是，原来对Ruby跟Git的完全不了解通过这两天的学习，也渐渐有点起色了。特别是对于Git的命令方面掌握了很多。感谢网上很多的Octopress教程，也是他们让我也想把自己搭建的过程分享出来，希望能节省一些人的时间。</p>
]]></content>
  </entry>
  
</feed>
